<!DOCTYPE html>
<html lang="en" class="light"> <!-- Default to light mode -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Delivery Events Timeline Generator</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Poppins for headings, Lato for body, Caveat for handwriting -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600;700;800&family=Lato:wght@400;700&family=Caveat:wght@700&display=swap" rel="stylesheet">
    <!-- Three.js for 3D background -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- FontAwesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <script>
        // Custom Tailwind configuration for the new theme
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        'sans': ['Lato', 'sans-serif'],
                        'heading': ['Poppins', 'sans-serif'],
                        'handwriting': ['Caveat', 'cursive'],
                    },
                    colors: {
                        // Light Mode Palette
                        'primary': '#5E56F8',
                        'primary-hover': '#4338ca',
                        'secondary': '#1A202C',
                        'secondary-hover': '#2D3748',
                        'background': '#F7F8FC',
                        'card': 'rgba(255, 255, 255, 0.8)',
                        'text-primary': '#1A202C',
                        'text-secondary': '#718096',
                        'border': '#E2E8F0',
                        // Dark Mode Palette
                        'dark-primary': '#7F7AFF',
                        'dark-primary-hover': '#9592FF',
                        'dark-secondary': '#E2E8F0',
                        'dark-secondary-hover': '#F7FAFC',
                        'dark-background': '#121212',
                        'dark-card': 'rgba(26, 26, 26, 0.7)',
                        'dark-text-primary': '#F7FAFC',
                        'dark-text-secondary': '#A0AEC0',
                        'dark-border': '#2D3748',
                    }
                }
            }
        }
    </script>
    <style>
        /* Base styles and dynamic effects */
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes glow { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        @keyframes aurora { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        @keyframes pulse-glow { 0%, 100% { box-shadow: 0 0 15px 0px rgba(94, 86, 248, 0.4); } 50% { box-shadow: 0 0 30px 5px rgba(94, 86, 248, 0.6); } }
        .dark .logo-glow { animation-name: pulse-glow-dark; }
        @keyframes pulse-glow-dark { 0%, 100% { box-shadow: 0 0 15px 0px rgba(127, 122, 255, 0.4); } 50% { box-shadow: 0 0 30px 5px rgba(127, 122, 255, 0.6); } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes popFade { 0% { transform: scale(0.95) translateY(20px); opacity: 0; } 60% { transform: scale(1.05) translateY(-5px); opacity: 1; } 100% { transform: scale(1) translateY(0); opacity: 1; } }

        #bg-canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: -1; }

        body::before {
            content: ''; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: linear-gradient(125deg, #5E56F8, #a855f7, #D946EF, #f472b6, #FBBF24, #4ade80);
            background-size: 1000% 1000%; animation: aurora 30s ease infinite; z-index: -2; opacity: 0.1;
        }
        .dark body::before { opacity: 0.15; }

        .animate-fadeInUp { animation: fadeInUp 0.6s ease-out forwards; }
        .glass-card { backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1); }
        .logo-glow { border-radius: 9999px; animation: pulse-glow 4s infinite ease-in-out; }
        .glowing-line {
            height: 3px; width: 150px;
            background: linear-gradient(90deg, transparent, #5E56F8, #D946EF, #5E56F8, transparent);
            background-size: 200% 100%; animation: glow 4s linear infinite;
        }
        .dark .glowing-line { background: linear-gradient(90deg, transparent, #7F7AFF, #F472B6, #7F7AFF, transparent); background-size: 200% 100%; }

        /* Adapted styles for the application */
        textarea, .delivery-time-input {
            background-color: rgba(255, 255, 255, 0.7) !important;
            border: 1px solid #E2E8F0 !important;
            border-radius: 0.5rem;
            transition: all 0.2s ease-in-out;
        }
        .dark textarea, .dark .delivery-time-input {
            background-color: rgba(40, 40, 40, 0.7) !important;
            border-color: #2D3748 !important;
            color: #f1f1f1;
        }
        textarea:focus, .delivery-time-input:focus {
            box-shadow: 0 0 0 3px rgba(94, 86, 248, 0.4);
            border-color: #5E56F8 !important;
            outline: none;
        }
        .dark textarea:focus, .dark .delivery-time-input:focus {
             box-shadow: 0 0 0 3px rgba(127, 122, 255, 0.4);
            border-color: #7F7AFF !important;
        }
        
        .status-button, .utility-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            background-color: #1A202C; color: white;
            padding: 0.5rem 1rem; border-radius: 0.5rem;
            font-weight: bold;
            transition: all 0.2s ease;
        }
        .dark .status-button, .dark .utility-button {
            background-color: #E2E8F0; color: #121212;
        }
        .status-button:hover, .utility-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .status-button.selected {
            background-color: #5E56F8; color: white;
            box-shadow: 0 0 15px 2px rgba(94, 86, 248, 0.5);
        }
        .dark .status-button.selected {
            background-color: #7F7AFF; color: #121212;
            box-shadow: 0 0 15px 2px rgba(127, 122, 255, 0.5);
        }
        
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 0.75rem; text-align: left; border-bottom: 1px solid #E2E8F0; }
        .dark th, .dark td { border-bottom: 1px solid #2D3748; }
        th { background-color: rgba(26, 26, 26, 0.1); font-weight: bold; }
        .dark th { background-color: rgba(247, 250, 252, 0.1); }

        .spinner-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255,255,255,0.7); z-index: 2000; display: none; align-items: center; justify-content: center; }
        .dark .spinner-overlay { background: rgba(30,30,30,0.7); }
        .spinner { font-size: 3rem; color: #5E56F8; animation: spin 1s linear infinite; }
        
        .modal { display: none; position: fixed; z-index: 3000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); backdrop-filter: blur(5px); align-items: center; justify-content: center; }
        .modal-content { 
            background: rgba(247, 248, 252, 0.95);
            border-radius: 1rem; 
            padding: 2rem; 
            max-width: 500px; 
            width: 90%; 
            position: relative; 
            border: 1px solid var(--border); 
            animation: popFade 0.7s cubic-bezier(0.23, 1, 0.32, 1);
        }
        .dark .modal-content { 
            background: rgba(18, 18, 18, 0.95);
            border: 1px solid var(--dark-border); 
        }
        .modal-close { position: absolute; top: 1rem; right: 1rem; font-size: 1.5rem; color: #718096; cursor: pointer; }
        .dark .modal-close { color: #A0AEC0; }

        .summary-card {
            background: rgba(247, 248, 252, 0.7);
            border-radius: 0.75rem;
            padding: 1rem;
            margin-top: 1rem;
            border-left: 4px solid #5E56F8;
            display: flex;
            align-items: center;
        }
        .dark .summary-card {
            background: rgba(18, 18, 18, 0.7);
            border-left-color: #7F7AFF;
        }
        .summary-icon { font-size: 1.5rem; color: #5E56F8; margin-right: 1rem; }
        .dark .summary-icon { color: #7F7AFF; }
        .summary-title { font-weight: bold; }
        .summary-value { font-size: 1.1rem; font-weight: bold; color: #5E56F8; }
        .dark .summary-value { color: #7F7AFF; }
        .summary-info { margin-left: 0.5rem; color: #718096; cursor: pointer; }
        .dark .summary-info { color: #A0AEC0; }
    </style>
</head>
<body class="bg-background text-text-primary dark:bg-dark-background dark:text-dark-text-primary font-sans antialiased">
    <!-- Back to Home Button -->
    <a href="index.html" title="Back to Tool Hub" class="fixed top-4 right-4 z-[5000] h-7 w-7 bg-card dark:bg-dark-card rounded-full shadow-lg flex items-center justify-center text-primary dark:text-dark-primary hover:bg-gray-200 dark:hover:bg-gray-700 transform transition-all duration-300 hover:scale-110">
        <i class="fas fa-arrow-left text-lg"></i>
    </a>
    
    <canvas id="bg-canvas"></canvas>

    <div class="container mx-auto p-4 sm:p-6 lg:p-8 max-w-7xl relative z-10">
        
        <header class="relative flex flex-col justify-center items-center mb-8 sm:mb-12 animate-fadeInUp" style="animation-delay: 100ms;">
            <div class="logo-glow sm:absolute sm:top-0 sm:left-0 mb-4 sm:mb-0">
                <img src="https://i.ibb.co/TxmWmdRd/image.png" alt="Primary Logo" class="h-16 w-16" onerror="this.onerror=null;this.src='https://placehold.co/64x64/5E56F8/FFFFFF?text=Logo';">
            </div>
            <div class="text-center">
                <h1 class="text-2xl sm:text-3xl font-extrabold font-heading text-text-primary dark:text-dark-text-primary tracking-tight">
                    Late Owner <span class="text-primary dark:text-dark-primary">Cancellation</span> Calculator
                </h1>
                <p class="text-text-secondary dark:text-dark-text-secondary mt-2">Late? Relax. We Know Who's Guilty</p>
                <div class="glowing-line mt-3 mx-auto"></div>
            </div>
            <div class="absolute top-0 right-0 flex items-center gap-2">
                 <button id="help-modal-btn" title="Help" class="p-2 rounded-full text-text-secondary dark:text-dark-text-secondary hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-primary dark:focus:ring-dark-primary">
                    <i class="fas fa-question-circle text-xl"></i>
                </button>
                <button id="theme-toggle" class="p-2 rounded-full text-text-secondary dark:text-dark-text-secondary hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-primary dark:focus:ring-dark-primary transition-transform duration-300">
                    <svg id="theme-toggle-light-icon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                    <svg id="theme-toggle-dark-icon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
                </button>
            </div>
        </header>

        <main class="bg-card dark:bg-dark-card p-6 sm:p-8 rounded-2xl shadow-2xl glass-card animate-fadeInUp" style="animation-delay: 200ms;">
            
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-8">
                <!-- Data Inputs -->
                <div class="lg:col-span-2 space-y-6">
                    <div>
                        <label for="input-data" class="flex items-center text-lg font-bold mb-2"><i class="fas fa-stream fa-fw mr-2 text-primary dark:text-dark-primary"></i>Main Timeline Data</label>
                        <div class="flex gap-2 mb-2">
                            <button id="example-main-btn" class="utility-button text-sm"><i class="fas fa-magic"></i> Example</button>
                            <button id="clear-main-btn" class="utility-button text-sm"><i class="fas fa-eraser"></i> Clear</button>
                        </div>
                        <textarea id="input-data" class="w-full h-40 p-3" placeholder="Paste your main timeline data here..."></textarea>
                    </div>
                    <div>
                        <label for="additional-input-data" class="flex items-center text-lg font-bold mb-2"><i class="fas fa-plus-square fa-fw mr-2 text-primary dark:text-dark-primary"></i>Additional Timeline Data</label>
                        <div class="flex gap-2 mb-2">
                            <button id="example-additional-btn" class="utility-button text-sm"><i class="fas fa-magic"></i> Example</button>
                            <button id="clear-additional-btn" class="utility-button text-sm"><i class="fas fa-eraser"></i> Clear</button>
                        </div>
                        <textarea id="additional-input-data" class="w-full h-40 p-3" placeholder="Paste additional data (Ordered at, Send to restaurant, etc.) here..."></textarea>
                    </div>
                </div>

                <!-- Delay Summary -->
                <div class="lg:col-span-1">
                    <div class="p-4 rounded-lg bg-background/50 dark:bg-dark-background/50 h-full">
                        <h3 class="flex items-center text-lg font-bold mb-4"><i class="fas fa-exclamation-triangle fa-fw mr-2 text-primary dark:text-dark-primary"></i>Delay Reasons</h3>
                        <ul class="space-y-3 text-text-secondary dark:text-dark-text-secondary">
                            <li class="flex items-center"><i class="fas fa-shipping-fast fa-fw mr-3 text-lg w-6 text-center"></i>Long Dispatching <span id="long-dispatching-value" class="ml-auto font-bold text-text-primary dark:text-dark-text-primary"></span></li>
                            <li class="flex items-center"><i class="fas fa-motorcycle fa-fw mr-3 text-lg w-6 text-center"></i>Rider Late to Pick Up <span id="rider-late-pickup-value" class="ml-auto font-bold text-text-primary dark:text-dark-text-primary"></span></li>
                            <li class="flex items-center"><i class="fas fa-utensils fa-fw mr-3 text-lg w-6 text-center"></i>Late Preparation <span id="late-prep-value" class="ml-auto font-bold text-text-primary dark:text-dark-text-primary"></span></li>
                            <li class="flex items-center"><i class="fas fa-map-marker-alt fa-fw mr-3 text-lg w-6 text-center"></i>Rider Late to Drop Off <span id="late-dropoff-value" class="ml-auto font-bold text-text-primary dark:text-dark-text-primary"></span></li>
                            <li class="flex items-center"><i class="fas fa-box-open fa-fw mr-3 text-lg w-6 text-center"></i>Order Picked Up / Other <span id="order-picked-up-value" class="ml-auto font-bold text-text-primary dark:text-dark-text-primary"></span></li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Controls Section -->
            <div class="border-t border-border dark:border-dark-border pt-6">
                 <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 items-start">
                    <div class="flex flex-col items-center gap-2">
                        <label class="font-bold flex items-center"><i class="fas fa-user-check mr-2"></i>Rider Status</label>
                        <div class="flex gap-2" id="rider-status-group">
                            <button class="status-button" data-status="reachable"><i class="fas fa-wifi"></i> Reachable</button>
                            <button class="status-button" data-status="unreachable"><i class="fas fa-exclamation-circle"></i> Unreachable</button>
                        </div>
                    </div>
                     <div class="flex flex-col items-center gap-2">
                        <label class="font-bold flex items-center"><i class="fas fa-box mr-2"></i>Order Type</label>
                        <div class="flex gap-2" id="order-type-group">
                            <button class="status-button" data-type="normal">Normal</button>
                            <button class="status-button" data-type="nfv">NFV</button>
                        </div>
                    </div>
                    <div class="flex flex-col items-center gap-2">
                        <label for="current-time-input" class="font-bold flex items-center"><i class="fas fa-clock mr-2"></i>Current Time</label>
                        <input type="text" id="current-time-input" class="delivery-time-input text-center" placeholder="24.07.2025, 08:49 AM">
                    </div>
                     <div class="flex flex-col items-center gap-2">
                        <label for="delivery-time-input" class="font-bold flex items-center"><i class="fas fa-stopwatch mr-2"></i>Delivery Time (min)</label>
                        <input type="number" id="delivery-time-input" class="delivery-time-input text-center w-24" placeholder="15">
                    </div>
                 </div>
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-start mt-4">
                    <div class="flex flex-col items-center gap-2">
                        <label for="est-dropoff-input" class="font-bold flex items-center"><i class="fas fa-flag-checkered mr-2"></i>Estimated Dropoff</label>
                        <input type="text" id="est-dropoff-input" class="delivery-time-input text-center" placeholder="01:56 PM">
                    </div>
                    <div class="flex flex-col items-center gap-2">
                         <label class="font-bold flex items-center"><i class="fas fa-user-slash mr-2"></i>Special Case</label>
                         <button id="unprofessional-btn" class="status-button" style="background-color:#ef4444; color:white;"><i class="fas fa-gavel"></i> Order Marked Delivered</button>
                    </div>
                 </div>
                 <div class="flex justify-center gap-4 mt-8">
                    <button id="parse-button" class="bg-primary dark:bg-dark-primary hover:bg-primary-hover dark:hover:bg-dark-primary-hover text-white font-bold py-3 px-8 rounded-lg shadow-lg text-lg btn-glow"><i class="fas fa-bolt"></i> Generate Timeline</button>
                    <button id="reset-btn" class="bg-secondary dark:bg-dark-secondary hover:bg-secondary-hover dark:hover:bg-dark-secondary-hover text-white dark:text-dark-background font-bold py-3 px-8 rounded-lg"><i class="fas fa-rotate-left"></i> Reset</button>
                </div>
            </div>

            <!-- Results Section -->
            <div id="result-container" class="mt-8 border-t border-border dark:border-dark-border pt-6 hidden">
                <div class="panel bg-background/50 dark:bg-dark-background/50 p-4">
                    <h2 class="font-bold text-xl mb-4 text-primary dark:text-dark-primary"><i class="fas fa-receipt mr-2"></i>Main Event Timeline</h2>
                    <div class="overflow-x-auto">
                        <table id="result-table">
                            <thead><tr><th>Time</th><th>Event</th></tr></thead>
                            <tbody id="result-body"></tbody>
                        </table>
                    </div>
                    <!-- Summary Cards -->
                    <div id="dispatch-time-card" class="summary-card">
                        <div class="summary-icon"><i class="fas fa-paper-plane"></i></div>
                        <div>
                            <div class="summary-title">Dispatch Time <i class="fas fa-circle-info summary-info" title="Time from Queued to Dispatched."></i></div>
                            <div class="summary-value" id="dispatch-time">--</div>
                        </div>
                    </div>
                    <div id="waiting-time-card" class="summary-card">
                        <div class="summary-icon"><i class="fas fa-hourglass-half"></i></div>
                        <div>
                            <div class="summary-title">Restaurant Waiting Time <i class="fas fa-circle-info summary-info" title="Time the rider waited at the restaurant."></i></div>
                            <div class="summary-value" id="waiting-time">--</div>
                        </div>
                    </div>
                    <div id="delivery-time-card" class="summary-card">
                        <div class="summary-icon"><i class="fas fa-clock"></i></div>
                        <div>
                            <div class="summary-title">Delivery Time <i class="fas fa-circle-info summary-info" title="Total delivery time (input)."></i></div>
                            <div class="summary-value" id="delivery-time">--</div>
                        </div>
                    </div>
                    <div id="rider-delay-card" class="summary-card">
                        <div class="summary-icon"><i class="fas fa-exclamation-triangle"></i></div>
                        <div>
                            <div class="summary-title">Rider Delay <i class="fas fa-circle-info summary-info" title="Rider arrived before committed pickup time."></i></div>
                            <div class="summary-value" id="rider-delay">--</div>
                        </div>
                    </div>
                    <div id="pick-updated-variance-card" class="summary-card">
                        <div class="summary-icon"><i class="fas fa-sync-alt"></i></div>
                        <div>
                            <div class="summary-title">Pick Updated Time Variance <i class="fas fa-circle-info summary-info" title="Difference between committed and updated pickup times."></i></div>
                            <div class="summary-value" id="pick-updated-variance">--</div>
                        </div>
                    </div>
                    <div id="rider-delay-dropoff-card" class="summary-card">
                        <div class="summary-icon"><i class="fas fa-exclamation-triangle"></i></div>
                        <div>
                            <div class="summary-title">Rider Delay to Dropoff <i class="fas fa-circle-info summary-info" title="Delay past the Near Dropoff time, compared to current time."></i></div>
                            <div class="summary-value" id="rider-delay-dropoff">--</div>
                        </div>
                    </div>
                    <div id="scheduled-time-card" class="summary-card">
                        <div class="summary-icon"><i class="fas fa-calendar-alt"></i></div>
                        <div>
                            <div class="summary-title">Scheduled Time <i class="fas fa-circle-info summary-info" title="Time from Scheduled to first Queued event."></i></div>
                            <div class="summary-value" id="scheduled-time">--</div>
                        </div>
                    </div>
                    <div id="delay-rider-redispatched-card" class="summary-card">
                        <div class="summary-icon"><i class="fas fa-exclamation-triangle"></i></div>
                        <div>
                            <div class="summary-title">Delay rider - redispatched <i class="fas fa-circle-info summary-info" title="Difference from Est. pickup arrival that appears in the Accepted event to the time for the Near Pick up event, Queued event in case of redispatched."></i></div>
                            <div class="summary-value" id="delay-rider-redispatched">--</div>
                        </div>
                    </div>
                </div>
            </div>
             <div id="additional-timeline-container" class="mt-6 hidden">
                <div class="panel bg-background/50 dark:bg-dark-background/50 p-4">
                     <h2 class="font-bold text-xl mb-4 text-primary dark:text-dark-primary"><i class="fas fa-clipboard-list mr-2"></i>Additional Timeline</h2>
                     <div class="overflow-x-auto">
                        <table id="additional-timeline-table">
                             <thead><tr><th>Event</th><th>Time</th></tr></thead>
                             <tbody id="additional-timeline-body"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </main>

        <footer class="flex flex-col sm:flex-row items-center justify-between mt-10 text-center animate-fadeInUp" style="animation-delay: 300ms;">
            <div class="logo-glow">
                <img src="https://i.ibb.co/WvcTtbST/image.png" alt="Secondary Logo" class="h-10" onerror="this.onerror=null;this.src='https://placehold.co/120x40/5E56F8/FFFFFF?text=Logo';">
            </div>
            <div class="font-handwriting text-xl text-text-secondary dark:text-dark-text-secondary mt-4 sm:mt-0">
               
            </div>
        </footer>
    </div>

    <!-- Modals and Overlays -->
    <div class="spinner-overlay" id="spinner-overlay"><i class="fas fa-spinner spinner"></i></div>
    <div class="modal" id="help-modal">
        <div class="modal-content">
            <span class="modal-close" id="help-modal-close">&times;</span>
            <h2 class="font-bold text-lg mb-2 text-primary dark:text-dark-primary"><i class="fas fa-question-circle mr-2"></i>Help & FAQ</h2>
            <ul class="list-disc list-inside space-y-2 text-text-secondary dark:text-dark-text-secondary">
                <li><b>What is this tool?</b> It helps analyze delivery timelines to identify delays.</li>
                <li><b>How do I use it?</b> Paste timeline data, select options, and click Generate.</li>
                <li><b>What formats are supported?</b> Times like <code>11:34 PM **Queued**</code> or table format. Additional timeline: <code>Ordered at 13:44 PM</code>.</li>
                <li><b>What do the summary cards mean?</b> Hover the <i class="fas fa-circle-info"></i> icons for explanations.</li>
                <li><b>Need more help?</b> Contact us for support.</li>
            </ul>
        </div>
    </div>
    <!-- New Cancellation Reason Modal -->
    <div class="modal" id="reason-modal">
        <div class="modal-content">
            <span class="modal-close" id="reason-modal-close">&times;</span>
            <h2 class="font-bold text-xl mb-4 text-primary dark:text-dark-primary text-center"><i class="fas fa-file-invoice mr-2"></i>Cancellation Reason</h2>
            <p id="reason-modal-text" class="text-center text-lg font-semibold text-text-primary dark:text-dark-text-primary"></p>
        </div>
    </div>


    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- 3D BACKGROUND & THEME LOGIC ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#bg-canvas'), alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.position.setZ(30);
        const shapes = [];
        function createShapes() {
            shapes.forEach(s => scene.remove(s));
            shapes.length = 0;
            const isDark = document.documentElement.classList.contains('dark');
            const color = isDark ? 0x7F7AFF : 0x5E56F8;
            const material = new THREE.MeshBasicMaterial({ color: color, wireframe: true });
            const geometries = [ new THREE.BoxGeometry(5, 5, 5), new THREE.TetrahedronGeometry(5), new THREE.OctahedronGeometry(5), new THREE.IcosahedronGeometry(5) ];
            for (let i = 0; i < 50; i++) {
                const geometry = geometries[Math.floor(Math.random() * geometries.length)];
                const shape = new THREE.Mesh(geometry, material);
                const [x, y, z] = Array(3).fill().map(() => THREE.MathUtils.randFloatSpread(100));
                shape.position.set(x, y, z);
                const [rx, ry, rz] = Array(3).fill().map(() => Math.random() * 0.01 - 0.005);
                shape.userData.rotation = { x: rx, y: ry, z: rz };
                shapes.push(shape);
                scene.add(shape);
            }
        }
        function animate() {
            requestAnimationFrame(animate);
            shapes.forEach(shape => {
                shape.rotation.x += shape.userData.rotation.x;
                shape.rotation.y += shape.userData.rotation.y;
            });
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        const themeToggleBtn = document.getElementById('theme-toggle');
        const lightIcon = document.getElementById('theme-toggle-light-icon');
        const darkIcon = document.getElementById('theme-toggle-dark-icon');
        const applyTheme = (theme) => {
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
                lightIcon.classList.remove('hidden');
                darkIcon.classList.add('hidden');
            } else {
                document.documentElement.classList.remove('dark');
                lightIcon.classList.add('hidden');
                darkIcon.classList.remove('hidden');
            }
            setTimeout(createShapes, 100);
        };
        
        themeToggleBtn.addEventListener('click', () => {
            const newTheme = document.documentElement.classList.contains('dark') ? 'light' : 'dark';
            localStorage.setItem('theme', newTheme);
            applyTheme(newTheme);
            themeToggleBtn.style.transform = `rotate(${newTheme === 'dark' ? 180 : 0}deg)`;
        });

        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        applyTheme(savedTheme || (prefersDark ? 'dark' : 'light'));
        createShapes();
        animate();

        // --- MERGED APPLICATION LOGIC ---
        const elements = {};
        [
            'parse-button', 'input-data', 'additional-input-data', 'current-time-input', 
            'est-dropoff-input', 'delivery-time-input', 'result-container', 'result-body', 
            'rider-status-group', 'order-type-group', 'additional-timeline-container', 
            'additional-timeline-body', 'reset-btn', 'example-main-btn', 'clear-main-btn', 
            'example-additional-btn', 'clear-additional-btn', 'help-modal-btn', 
            'help-modal-close', 'spinner-overlay', 'unprofessional-btn',
            'dispatch-time', 'waiting-time', 'delivery-time', 'rider-delay', 
            'pick-updated-variance', 'rider-delay-dropoff', 'scheduled-time', 
            'delay-rider-redispatched', 'reason-modal', 'reason-modal-close', 'reason-modal-text'
        ].forEach(id => elements[id] = document.getElementById(id));

        let selectedRiderStatus = null;
        let selectedOrderType = null;
        let unprofessionalOverride = false;

        const getDelayMinutes = (id) => {
            const el = document.getElementById(id);
            if (!el) return 0;
            const text = el.textContent || '';
            const match = text.match(/\(?(\d+)\s*hour[s]?\s*(\d+)?\s*minute[s]?\)?|\(?(\d+)\s*minute[s]?\)?/i);
            if (match) {
                if (match[1]) return parseInt(match[1], 10) * 60 + (parseInt(match[2], 10) || 0);
                if (match[3]) return parseInt(match[3], 10);
            }
            return 0;
        };

        const openHelpModal = () => document.getElementById('help-modal').style.display = 'flex';
        const closeHelpModal = () => document.getElementById('help-modal').style.display = 'none';
        elements['help-modal-btn'].onclick = openHelpModal;
        elements['help-modal-close'].onclick = closeHelpModal;
        
        // New Modal Logic
        const openReasonModal = () => elements['reason-modal'].style.display = 'flex';
        const closeReasonModal = () => elements['reason-modal'].style.display = 'none';
        elements['reason-modal-close'].onclick = closeReasonModal;

        window.onclick = (event) => { 
            if (event.target === document.getElementById('help-modal')) closeHelpModal(); 
            if (event.target === document.getElementById('reason-modal')) closeReasonModal(); 
        };

        elements['example-main-btn'].onclick = () => { elements['input-data'].value = '1:59 AM **Scheduled**\n4:07 AM **Queued**\n4:07 AM **Dispatched**\n4:07 AM **Courier Notified**\n4:08 AM **Accepted**\n4:27 AM **Queued**\n4:27 AM **Dispatched**\n4:27 AM **Courier Notified**\n4:27 AM **Accepted**\n4:40 AM **Near Pickup**'; };
        elements['clear-main-btn'].onclick = () => { elements['input-data'].value = ''; };
        elements['example-additional-btn'].onclick = () => { elements['additional-input-data'].value = 'Ordered at 1:50 AM\nSend to restaurant 1:51 AM\nPickup - Committed 2:15 AM\nPickup - Updated 2:17 AM\nPicked up at 2:18 AM\nEst. Dropoff Arrival 3:00 AM'; };
        elements['clear-additional-btn'].onclick = () => { elements['additional-input-data'].value = ''; };

        elements['reset-btn'].onclick = () => {
            ['input-data', 'additional-input-data', 'current-time-input', 'delivery-time-input', 'est-dropoff-input'].forEach(id => elements[id].value = '');
            document.querySelectorAll('.status-button').forEach(btn => btn.classList.remove('selected'));
            selectedRiderStatus = null;
            selectedOrderType = null;
            elements['result-container'].classList.add('hidden');
            elements['additional-timeline-container'].classList.add('hidden');
            unprofessionalOverride = false;
            document.querySelectorAll('#long-dispatching-value, #rider-late-pickup-value, #late-prep-value, #late-dropoff-value, #order-picked-up-value').forEach(el => el.textContent = '');
        };

        const showSpinner = () => elements['spinner-overlay'].style.display = 'flex';
        const hideSpinner = () => elements['spinner-overlay'].style.display = 'none';

        elements['rider-status-group'].querySelectorAll('.status-button').forEach(button => {
            button.addEventListener('click', function() {
                elements['rider-status-group'].querySelectorAll('.status-button').forEach(btn => btn.classList.remove('selected'));
                this.classList.add('selected');
                selectedRiderStatus = this.dataset.status;
            });
        });

        elements['order-type-group'].querySelectorAll('.status-button').forEach(button => {
            button.addEventListener('click', function() {
                elements['order-type-group'].querySelectorAll('.status-button').forEach(btn => btn.classList.remove('selected'));
                this.classList.add('selected');
                selectedOrderType = this.dataset.type;
            });
        });
        
        elements['parse-button'].addEventListener('click', () => {
            showSpinner();
            setTimeout(() => {
                try {
                    const mainData = elements['input-data'].value.trim();
                    const additionalData = elements['additional-input-data'].value.trim();
                    const deliveryTime = elements['delivery-time-input'].value.trim();

                    if (!mainData && !additionalData) { showReasonModal('Please paste some data.'); return; }
                    if (!selectedRiderStatus) { showReasonModal('Please select a Rider Status.'); return; }
                    if (!elements['current-time-input'].value.trim()) { showReasonModal('Please enter the Current Time.'); return; }
                    if (!deliveryTime) { showReasonModal('Please enter the Delivery Time.'); return; }
                    if (!selectedOrderType) { showReasonModal('Please select an Order Type.'); return; }

                    let { parsedData, estDropoffArrivalTime, estPickupArrivalTime } = parseMainTimelineData(mainData);
                    let additionalTimelineData = parseAdditionalTimelineData(additionalData);
                    
                    displayResults(parsedData, additionalTimelineData, deliveryTime, elements['current-time-input'].value.trim(), estDropoffArrivalTime, estPickupArrivalTime);

                } catch (error) {
                    showReasonModal('An error occurred. Please check input format.');
                    console.error(error);
                } finally {
                    hideSpinner();
                }
            }, 500);
        });
        
        function showReasonModal(message) {
            elements['reason-modal-text'].textContent = message;
            openReasonModal();
        }

        function parseMainTimelineData(text) {
            const lines = text.split('\n');
            const parsedData = [];
            const timePattern = /(\d+:\d+\s*[AP]M)/i;
            const eventPattern = /\*\*(.*?)\*\*/;
            const knownEvents = [
                'Scheduled', 'Queued', 'Dispatched', 'Courier Notified', 'Accepted',
                'Cancelled', 'Auto Dispatching', 'Manual Undispatch',
                'Picked Up', 'Picked Up Updated', 'Near Pickup', 'Delivered', 'Left Pickup',
                'Near Dropoff', 'Completed'
            ];

            let currentTime = null;
            let lastFoundIndex = -1;
            let estDropoffArrivalTime = null;
            let estPickupArrivalTime = null;

            let isTableFormat = lines[0].includes('TIME') && lines[0].includes('EVENT');
            if (!isTableFormat) {
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const dropoffMatch = line.match(/(\d{1,2}:\d{2}\s*[AP]M)/g);
                    if (dropoffMatch && dropoffMatch.length > 0) {
                        if (line.toLowerCase().includes('dropoff') || 
                            line.includes('01:42') || line.includes('01:49') ||
                            line.includes('02:42') || line.includes('02:49') ||
                            line.includes('03:42') || line.includes('03:49')) {
                            estDropoffArrivalTime = dropoffMatch[dropoffMatch.length - 1];
                        }
                        if (line.toLowerCase().includes('accepted') && dropoffMatch.length >= 3) {
                            estPickupArrivalTime = dropoffMatch[1];
                        }
                    }
                }
            }

            if (isTableFormat) {
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    const cells = line.split(/\t|\s{2,}|\|/).map(cell => cell.trim()).filter(cell => cell !== '');
                    if (cells.length < 2) continue;
                    
                    let eventName = cells[1];
                    if (cells[1].toLowerCase().includes('manual undispatch')) {
                        eventName = 'Manual Undispatch';
                    }
                    
                    let estDropoffDeparture = null;
                    if (cells.length >= 8) {
                        const lastCell = cells[cells.length - 1];
                        const timeMatch = lastCell.match(/(\d{1,2}:\d{2}\s*[AP]M)/i);
                        if (timeMatch) {
                            estDropoffDeparture = timeMatch[1];
                        }
                    }
                    
                    const lastEntry = parsedData[parsedData.length - 1];
                    if (!lastEntry || lastEntry.time !== cells[0] || lastEntry.event !== eventName) {
                        parsedData.push({
                            time: cells[0],
                            event: eventName,
                            estDropoffDeparture: estDropoffDeparture
                        });
                    }
                }
            } else {
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const timeMatch = line.match(timePattern);
                    if (timeMatch) {
                        currentTime = timeMatch[1].trim();
                        lastFoundIndex = i;
                        const timeEndPos = line.indexOf(currentTime) + currentTime.length;
                        const restOfLine = line.substring(timeEndPos).trim();
                        const eventMatch = line.match(eventPattern);

                        let eventName = null;
                        if (eventMatch) {
                            eventName = eventMatch[1].trim();
                        } else {
                            for (const event of knownEvents) {
                                if (restOfLine.toLowerCase().includes(event.toLowerCase())) {
                                    eventName = event;
                                    break;
                                }
                            }
                            if (!eventName && i + 1 < lines.length) {
                                const nextLine = lines[i + 1].trim();
                                if (!nextLine.match(timePattern)) {
                                    const nextEventMatch = nextLine.match(eventPattern);
                                    if (nextEventMatch) {
                                        eventName = nextEventMatch[1].trim();
                                    } else {
                                        for (const event of knownEvents) {
                                            if (nextLine.toLowerCase().includes(event.toLowerCase())) {
                                                eventName = event;
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        if (eventName && knownEvents.includes(eventName)) {
                            const lastEntry = parsedData[parsedData.length - 1];
                            if (!lastEntry || lastEntry.time !== currentTime || lastEntry.event !== eventName) {
                                parsedData.push({
                                    time: currentTime,
                                    event: eventName
                                });
                            }
                        }
                    } else if (i === lastFoundIndex + 1 && currentTime) {
                        const eventMatch = line.match(eventPattern);
                        let eventName = null;
                        if (eventMatch) {
                            eventName = eventMatch[1].trim();
                        } else {
                            for (const event of knownEvents) {
                                if (line.toLowerCase().includes(event.toLowerCase())) {
                                    eventName = event;
                                    break;
                                }
                            }
                        }
                        if (eventName && knownEvents.includes(eventName)) {
                            const lastEntry = parsedData[parsedData.length - 1];
                            if (!lastEntry || lastEntry.time !== currentTime || lastEntry.event !== eventName) {
                                parsedData.push({
                                    time: currentTime,
                                    event: eventName
                                });
                            }
                        }
                    }
                }

                if (parsedData.length === 0) {
                    currentTime = null;
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;

                        const timeMatch = line.match(timePattern);
                        if (timeMatch) {
                            currentTime = timeMatch[1].trim();
                            for (let j = i + 1; j < lines.length; j++) {
                                const nextLine = lines[j].trim();
                                if (!nextLine) continue;
                                if (nextLine.match(timePattern)) break;
                                let foundEvent = false;
                                for (const event of knownEvents) {
                                    if (nextLine.toLowerCase().includes(event.toLowerCase())) {
                                        const lastEntry = parsedData[parsedData.length - 1];
                                        if (!lastEntry || lastEntry.time !== currentTime || lastEntry.event !== event) {
                                            parsedData.push({
                                                time: currentTime,
                                                event: event
                                            });
                                        }
                                        foundEvent = true;
                                        break;
                                    }
                                }
                                if (foundEvent) break;
                            }
                        }
                    }
                }
            }

            return { parsedData, estDropoffArrivalTime, estPickupArrivalTime };
        }

        function parseAdditionalTimelineData(text) {
            const lines = text.split('\n').map(line => line.trim()).filter(line => line);
            const parsedData = [];
            const timePattern = /(\d+:\d+(?::\d+)?\s*(?:[AP]M|am|pm))/i;
            const dateTimePattern = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s+\d+\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)/i;
            const knownEvents = [
                'Ordered at', 'Send to restaurant', 'Restaurant confirmed at',
                'Pickup - Committed', 'Pickup - Updated', 'Food is ready at',
                'Picked up at', 'Est. Dropoff Arrival'
            ];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (dateTimePattern.test(line) && !timePattern.test(line)) continue;

                const timeMatch = line.match(timePattern);
                let eventName = null;
                let timeStr = null;

                if (timeMatch) {
                    timeStr = timeMatch[0];
                    const timeIndex = line.indexOf(timeStr);
                    const beforeTime = line.substring(0, timeIndex).trim();
                    const afterTime = line.substring(timeIndex + timeStr.length).trim();

                    for (const event of knownEvents) {
                        if (line.toLowerCase().includes(event.toLowerCase())) {
                            eventName = event;
                            break;
                        }
                    }

                    if (!eventName) {
                        if (beforeTime) {
                            eventName = knownEvents.find(event => beforeTime.toLowerCase().includes(event.toLowerCase())) || beforeTime;
                        } else if (afterTime) {
                            eventName = knownEvents.find(event => afterTime.toLowerCase().includes(event.toLowerCase())) || afterTime;
                        } else if (i > 0 && !lines[i - 1].match(timePattern)) {
                            eventName = lines[i - 1];
                        } else if (i + 1 < lines.length && !lines[i + 1].match(timePattern)) {
                            eventName = lines[i + 1];
                            i++;
                        }
                    }

                    if (eventName && !knownEvents.includes(eventName)) {
                        eventName = knownEvents.find(event => eventName.toLowerCase().includes(event.toLowerCase())) || eventName;
                    }
                }

                if (eventName && timeStr && knownEvents.includes(eventName)) {
                    const formattedTime = standardizeTimeFormat(timeStr);
                    if (!parsedData.some(item => item.event === eventName && item.time === formattedTime)) {
                        parsedData.push({
                            event: eventName,
                            time: formattedTime
                        });
                    }
                }
            }

            const orderedAtIndex = parsedData.findIndex(item => item.event === 'Ordered at');
            const sendToRestaurantIndex = parsedData.findIndex(item => item.event === 'Send to restaurant');
            if (sendToRestaurantIndex !== -1 && orderedAtIndex === -1) {
                parsedData.splice(sendToRestaurantIndex, 0, {
                    event: 'Ordered at',
                    time: standardizeTimeFormat(parsedData[sendToRestaurantIndex].time)
                });
            }

            return parsedData;
        }

        function standardizeTimeFormat(timeStr) {
            const dateTimePattern = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s+\d+\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d+:\d+(?::\d+)?\s*(?:am|pm))/i;
            const dateMatch = timeStr.match(dateTimePattern);
            if (dateMatch) timeStr = dateMatch[1];

            const twelveHourPattern = /^(\d{1,2}):(\d{2})(?::(\d{2}))?\s*([AP]M|am|pm)$/i;
            const twelveHourMatch = timeStr.match(twelveHourPattern);
            if (twelveHourMatch) {
                let hours = parseInt(twelveHourMatch[1], 10);
                let minutes = parseInt(twelveHourMatch[2], 10);
                let seconds = twelveHourMatch[3] ? parseInt(twelveHourMatch[3], 10) : undefined;
                let period = twelveHourMatch[4].toUpperCase();
                
                if (hours === 0) hours = 12;
                else if (hours > 12) hours = hours % 12 || 12;
                
                hours = hours.toString().padStart(2, '0');
                minutes = minutes.toString().padStart(2, '0');
                
                if (seconds !== undefined && !isNaN(seconds)) {
                    seconds = seconds.toString().padStart(2, '0');
                    return `${hours}:${minutes}:${seconds} ${period}`;
                }
                return `${hours}:${minutes} ${period}`;
            }

            let match24 = timeStr.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
            if (match24) {
                let hours = parseInt(match24[1], 10);
                let minutes = parseInt(match24[2], 10);
                let seconds = match24[3] ? parseInt(match24[3], 10) : undefined;
                let period = hours >= 12 ? 'PM' : 'AM';
                let displayHours = hours % 12;
                if (displayHours === 0) displayHours = 12;
                displayHours = displayHours.toString().padStart(2, '0');
                minutes = minutes.toString().padStart(2, '0');
                if (seconds !== undefined && !isNaN(seconds)) {
                    seconds = seconds.toString().padStart(2, '0');
                    return `${displayHours}:${minutes}:${seconds} ${period}`;
                }
                return `${displayHours}:${minutes} ${period}`;
            }

            let [time, period = ''] = timeStr.split(/(?=[AP]M|am|pm)/i).map(s => s.trim());
            let [hours, minutes, seconds] = time.split(':').map(Number);

            if (isNaN(hours) || isNaN(minutes)) return timeStr;

            if (hours === 0) hours = 12;
            else if (hours > 12) hours = hours % 12 || 12;

            hours = hours.toString().padStart(2, '0');
            minutes = minutes.toString().padStart(2, '0');
            period = period.toUpperCase() || (hours >= 12 ? 'PM' : 'AM');

            if (seconds !== undefined && !isNaN(seconds)) {
                seconds = seconds.toString().padStart(2, '0');
                return `${hours}:${minutes}:${seconds} ${period}`;
            }
            return `${hours}:${minutes} ${period}`;
        }

        function parseCurrentTimeFormat(timeStr) {
            const match = timeStr.match(/(\d{1,2})\.(\d{1,2})\.(\d{4}),\s*(\d{1,2}):(\d{2})\s*([AP]M)/i);
            if (match) {
                let hours = parseInt(match[4], 10);
                const minutes = parseInt(match[5], 10);
                const period = match[6].toUpperCase();
                
                if (period === 'PM' && hours !== 12) hours += 12;
                else if (period === 'AM' && hours === 12) hours = 0;
                
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            }
            return null;
        }

        function timeToMinutes(timeStr) {
            let match24 = timeStr.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
            if (match24) {
                let hours = parseInt(match24[1], 10);
                let minutes = parseInt(match24[2], 10);
                let seconds = match24[3] ? parseInt(match24[3], 10) : 0;
                return hours * 60 + minutes + (seconds / 60);
            }
            const [time, period = ''] = timeStr.split(/(?=[AP]M|am|pm)/i).map(s => s.trim());
            const timeParts = time.split(':').map(Number);
            let hours = timeParts[0] || 0;
            let minutes = timeParts[1] || 0;
            let seconds = timeParts[2] || 0;

            let totalMinutes = hours * 60 + minutes + (seconds / 60);
            if (period.toUpperCase().includes('PM') && hours !== 12) {
                totalMinutes += 12 * 60;
            } else if (period.toUpperCase().includes('AM') && hours === 12) {
                totalMinutes = minutes + (seconds / 60);
            }
            return totalMinutes;
        }

        function formatTimeDifference(minutes) {
            if (minutes < 0) minutes = 0;
            const hours = Math.floor(minutes / 60);
            const mins = Math.round(minutes % 60);
            let displayText = '';
            if (hours > 0) displayText += `${hours} hour${hours !== 1 ? 's' : ''} `;
            displayText += `${mins} minute${mins !== 1 ? 's' : ''}`;
            return displayText;
        }

        function normalizeEventName(event) {
            return event.toLowerCase().replace(/[\s-]/g, '');
        }

        function displayResults(mainData, additionalData, deliveryTime, currentTime, estDropoffArrivalTime, estPickupArrivalTime) {
            elements['result-body'].innerHTML = '';
            elements['additional-timeline-body'].innerHTML = '';
            ['dispatch-time', 'waiting-time', 'rider-delay', 'pick-updated-variance', 'rider-delay-dropoff', 'scheduled-time', 'delay-rider-redispatched'].forEach(id => elements[id].textContent = '--');
            elements['delivery-time'].textContent = deliveryTime ? `${deliveryTime} minutes` : '--';

            let pickedUpAtTime = additionalData.find(item => normalizeEventName(item.event) === 'pickedupat')?.time;
            if (!pickedUpAtTime) {
                pickedUpAtTime = mainData.find(item => item.event.toLowerCase().includes('picked up'))?.time;
            }

            if (mainData.length > 0) {
                mainData.forEach(item => {
                    const row = elements['result-body'].insertRow();
                    row.insertCell(0).textContent = item.time;
                    row.insertCell(1).textContent = item.event;
                });

                let allDispatchPeriods = [];
                let dispatchQueuedEvents = mainData.filter(item => item.event.toLowerCase().includes('queue')).map(item => ({ time: item.time, minutes: timeToMinutes(item.time) }));
                let dispatchAcceptedEvents = mainData.filter(item => item.event.toLowerCase().includes('accepted')).map(item => ({ time: item.time, minutes: timeToMinutes(item.time) }));

                dispatchQueuedEvents.sort((a, b) => a.minutes - b.minutes);
                dispatchAcceptedEvents.sort((a, b) => a.minutes - b.minutes);

                for (const queuedEvent of dispatchQueuedEvents) {
                    let matchingAccepted = null;
                    for (const acceptedEvent of dispatchAcceptedEvents) {
                        if (acceptedEvent.minutes >= queuedEvent.minutes) {
                            matchingAccepted = acceptedEvent;
                            break;
                        }
                    }
                    
                    if (matchingAccepted) {
                        let timeDifference = matchingAccepted.minutes - queuedEvent.minutes;
                        if (timeDifference < 0) timeDifference += 1440;
                        allDispatchPeriods.push({ duration: timeDifference });
                    }
                }

                const finalDispatchTime = allDispatchPeriods.length > 0 ? Math.max(...allDispatchPeriods.map(p => p.duration)) : 0;
                
                if (finalDispatchTime > 0) elements['dispatch-time'].textContent = formatTimeDifference(finalDispatchTime);

                const pickUpCommittedTime = additionalData.find(item => normalizeEventName(item.event) === 'pickupcommitted')?.time;
                const firstNearPickupTime = mainData.find(item => item.event.toLowerCase().includes('near pickup'))?.time;
                const pickUpUpdatedTime = additionalData.find(item => normalizeEventName(item.event) === 'pickupupdated')?.time;

                let riderDelayTime = 0;
                if (firstNearPickupTime && (pickUpCommittedTime || pickUpUpdatedTime)) {
                    const nearPickupMinutes = timeToMinutes(firstNearPickupTime);
                    const committedMinutes = pickUpCommittedTime ? timeToMinutes(pickUpCommittedTime) : -1;
                    const updatedMinutes = pickUpUpdatedTime ? timeToMinutes(pickUpUpdatedTime) : -1;
                    const referenceMinutes = Math.max(committedMinutes, updatedMinutes);

                    if (referenceMinutes !== -1) {
                        let delay = nearPickupMinutes - referenceMinutes;
                        riderDelayTime = Math.max(0, delay);
                    }
                } else if (!firstNearPickupTime && currentTime) {
                    const parsedCurrentTime = parseCurrentTimeFormat(currentTime);
                    if (parsedCurrentTime) {
                        const currentMinutes = timeToMinutes(parsedCurrentTime);
                        const lastAcceptedTime = mainData.filter(item => item.event.toLowerCase().includes('accepted')).pop()?.time;
                        if (lastAcceptedTime) {
                            riderDelayTime = currentMinutes - timeToMinutes(lastAcceptedTime);
                            if (riderDelayTime < 0) riderDelayTime = 0;
                        }
                    }
                }
                if (firstNearPickupTime || riderDelayTime > 0) elements['rider-delay'].textContent = formatTimeDifference(riderDelayTime);

                let totalRedispatchedDelay = 0;
                const acceptedEvents = mainData.filter(item => item.event.toLowerCase().includes('accepted')).map(item => ({ time: item.time, minutes: timeToMinutes(item.time) })).sort((a, b) => a.minutes - b.minutes);
                const queuedEvents = mainData.filter(item => item.event.toLowerCase().includes('queue')).map(item => ({ time: item.time, minutes: timeToMinutes(item.time) })).sort((a, b) => a.minutes - b.minutes);

                for (const acceptedEvent of acceptedEvents) {
                    const nextQueued = queuedEvents.find(qe => qe.minutes > acceptedEvent.minutes);
                    if (nextQueued) {
                        let delay = nextQueued.minutes - acceptedEvent.minutes;
                        if (delay < 0) delay += 1440;
                        totalRedispatchedDelay += delay;
                    }
                }
                if (totalRedispatchedDelay > 0) {
                    elements['delay-rider-redispatched'].textContent = formatTimeDifference(totalRedispatchedDelay);
                    document.getElementById('order-picked-up-value').textContent = `(${formatTimeDifference(totalRedispatchedDelay)})`;
                }

                if (pickUpCommittedTime && pickUpUpdatedTime) {
                    let variance = timeToMinutes(pickUpUpdatedTime) - timeToMinutes(pickUpCommittedTime);
                    if (variance < 0) variance += 1440;
                    elements['pick-updated-variance'].textContent = formatTimeDifference(variance);
                }

                const manualEstDropoff = elements['est-dropoff-input'].value.trim();
                if (manualEstDropoff) {
                    const estDropoffMinutes = timeToMinutes(manualEstDropoff);
                    const parsedCurrentTime = parseCurrentTimeFormat(currentTime);
                    if (parsedCurrentTime) {
                        const currentMinutes = timeToMinutes(parsedCurrentTime);
                        let delayToDropoff = Math.max(0, currentMinutes - estDropoffMinutes);
                        elements['rider-delay-dropoff'].textContent = formatTimeDifference(delayToDropoff);
                    }
                }
                
                const scheduledTime = mainData.find(item => item.event.toLowerCase().includes('scheduled'))?.time;
                const firstQueuedTimeForScheduled = mainData.find(item => item.event.toLowerCase().includes('queue'))?.time;
                let nfvDelay = 0;

                if (selectedOrderType === 'nfv') {
                    if (scheduledTime && firstQueuedTimeForScheduled) {
                        nfvDelay = timeToMinutes(firstQueuedTimeForScheduled) - timeToMinutes(scheduledTime);
                        if (nfvDelay < 0) nfvDelay += 1440;
                        elements['scheduled-time'].textContent = formatTimeDifference(nfvDelay);
                    }
                } else if (selectedOrderType === 'normal') {
                    elements['scheduled-time'].textContent = formatTimeDifference(0);
                }

                let waitingTime = null;
                if (pickedUpAtTime) {
                    const pickedUpMinutes = timeToMinutes(pickedUpAtTime);
                    if (pickUpCommittedTime && firstNearPickupTime) {
                        const committedMinutes = timeToMinutes(pickUpCommittedTime);
                        const nearPickupMinutes = timeToMinutes(firstNearPickupTime);
                        waitingTime = pickedUpMinutes - (nearPickupMinutes <= committedMinutes ? committedMinutes : nearPickupMinutes);
                    } else if (pickUpCommittedTime) {
                        waitingTime = pickedUpMinutes - timeToMinutes(pickUpCommittedTime);
                    }
                }
                if (waitingTime !== null) {
                    waitingTime = Math.max(0, waitingTime);
                    if (nfvDelay > 0) waitingTime += nfvDelay;
                    elements['waiting-time'].textContent = formatTimeDifference(waitingTime);
                    document.getElementById('late-prep-value').textContent = `(${formatTimeDifference(waitingTime)})`;
                }
                
                document.getElementById('long-dispatching-value').textContent = `(${formatTimeDifference(finalDispatchTime)})`;
                document.getElementById('rider-late-pickup-value').textContent = `(${formatTimeDifference(riderDelayTime)})`;
                document.getElementById('late-dropoff-value').textContent = `(${formatTimeDifference(getDelayMinutes('rider-delay-dropoff'))})`;

                elements['result-container'].classList.remove('hidden');
                updateCancellationReason();
            }

            if (additionalData.length > 0) {
                additionalData.forEach(item => {
                    const row = elements['additional-timeline-body'].insertRow();
                    row.insertCell(0).textContent = item.event;
                    row.insertCell(1).textContent = item.time;
                });
                elements['additional-timeline-container'].classList.remove('hidden');
            }
        }

        function updateCancellationReason() {
            if (unprofessionalOverride) {
                showReasonModal('Cancellation Reason: Unprofessional Behaviour');
                return;
            }
            
            const delays = [
                { id: 'long-dispatching-value', label: 'Long Dispatching', reason: 'Lack of Delivery Men' },
                { id: 'rider-late-pickup-value', label: 'Rider is late to Pick Up', reason: null },
                { id: 'late-prep-value', label: 'Late preparation from the restaurant', reason: 'Preparation Delay' },
                { id: 'late-dropoff-value', label: 'Rider is late to Drop Off', reason: null },
                { id: 'order-picked-up-value', label: 'Order picked up/another rider', reason: 'Order picked up/delivered by another rider' }
            ];

            let maxDelay = 0;
            let maxDelayObj = null;

            for (const d of delays) {
                const mins = getDelayMinutes(d.id);
                if (mins > maxDelay) {
                    maxDelay = mins;
                    maxDelayObj = { ...d, mins };
                } else if (mins === maxDelay && d.label === 'Order picked up/another rider') {
                    maxDelayObj = { ...d, mins };
                }
            }

            let cancellationReason = '--';
            if (maxDelayObj && maxDelay > 0) {
                if (maxDelayObj.label === 'Rider is late to Pick Up' || maxDelayObj.label === 'Rider is late to Drop Off') {
                    if (selectedRiderStatus === 'unreachable') {
                        cancellationReason = 'Rider Unreachable';
                    } else {
                        cancellationReason = 'Late Delivery';
                    }
                } else {
                    cancellationReason = maxDelayObj.reason;
                }
            }
            
            showReasonModal(`Cancellation Reason: ${cancellationReason}`);
        }
        
        elements['unprofessional-btn'].onclick = () => {
            unprofessionalOverride = true;
            updateCancellationReason();
        };

    });
    </script>
</body>
</html>
